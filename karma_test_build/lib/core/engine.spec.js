"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Block2_1 = require("../engine2D/Block2");
var Dynamics2_1 = require("../engine2D/Dynamics2");
var Euclidean2_1 = require("../engine2D/Euclidean2");
var Block3_1 = require("../engine3D/Block3");
var Dynamics3_1 = require("../engine3D/Dynamics3");
var Euclidean3_1 = require("../engine3D/Euclidean3");
var Geometric2_1 = require("../math/Geometric2");
var Geometric3_1 = require("../math/Geometric3");
var Unit_1 = require("../math/Unit");
var ConstantForceLaw_1 = require("./ConstantForceLaw");
var Engine_1 = require("./Engine");
var Spring_1 = require("./Spring");
describe("engine", function () {
    describe("static", function () {
        it("Euclidean2D", function () {
            var metric = new Euclidean2_1.Euclidean2();
            var dynamics = new Dynamics2_1.Dynamics2();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block2_1.Block2(Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER), Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER));
            expect(block.X.a).toBe(0);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.b).toBe(0);
            engine.contents.addBody(block);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.a).toBe(0);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.b).toBe(0);
        });
        it("Euclidean3D", function () {
            var metric = new Euclidean3_1.Euclidean3();
            var dynamics = new Dynamics3_1.Dynamics3();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block3_1.Block3(Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER));
            engine.contents.addBody(block);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
        });
    });
    describe("constant velocity", function () {
        it("Euclidean2D", function () {
            var metric = new Euclidean2_1.Euclidean2();
            var dynamics = new Dynamics2_1.Dynamics2();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block2_1.Block2(Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER), Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER));
            block.P.x = 1;
            block.P.y = 2;
            expect(block.X.a).toBe(0);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.b).toBe(0);
            engine.contents.addBody(block);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.a).toBe(0);
            expect(block.X.x).toBe(1);
            expect(block.X.y).toBe(2);
            expect(block.X.b).toBe(0);
        });
        it("Euclidean3D", function () {
            var metric = new Euclidean3_1.Euclidean3();
            var dynamics = new Dynamics3_1.Dynamics3();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block3_1.Block3(Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER));
            block.P.x = 1;
            block.P.y = 2;
            block.P.z = 3;
            engine.contents.addBody(block);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(1);
            expect(block.X.y).toBe(2);
            expect(block.X.z).toBe(3);
        });
    });
    describe("constant force", function () {
        it("Euclidean2D", function () {
            var metric = new Euclidean2_1.Euclidean2();
            var dynamics = new Dynamics2_1.Dynamics2();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block2_1.Block2(Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER), Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER));
            block.M = Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.KILOGRAM);
            block.P.x = 0;
            block.P.y = 0;
            block.P.uom = Unit_1.Unit.KILOGRAM_METER_PER_SECOND;
            var F = new ConstantForceLaw_1.ConstantForceLaw(block, Geometric2_1.Geometric2.vector(1, 0, Unit_1.Unit.NEWTON));
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            engine.contents.addBody(block);
            engine.contents.addForceLaw(F);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(0.5);
            expect(block.X.y).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(2);
            expect(block.X.y).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(4.5);
            expect(block.X.y).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(8);
            expect(block.X.y).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(12.5);
            expect(block.X.y).toBe(0);
        });
        it("Euclidean3D", function () {
            var metric = new Euclidean3_1.Euclidean3();
            var dynamics = new Dynamics3_1.Dynamics3();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block3_1.Block3(Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER));
            block.M = Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.KILOGRAM);
            block.P.x = 0;
            block.P.y = 0;
            block.P.uom = Unit_1.Unit.KILOGRAM_METER_PER_SECOND;
            var F = new ConstantForceLaw_1.ConstantForceLaw(block, Geometric3_1.Geometric3.vector(1, 0, 0, Unit_1.Unit.NEWTON));
            engine.contents.addBody(block);
            engine.contents.addForceLaw(F);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(0.5);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
        });
    });
    describe("spring force", function () {
        it("Euclidean2D", function () {
            var metric = new Euclidean2_1.Euclidean2();
            var dynamics = new Dynamics2_1.Dynamics2();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block1 = new Block2_1.Block2(Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER), Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER));
            block1.M = Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.KILOGRAM);
            block1.X = Geometric2_1.Geometric2.vector(-1, 0, Unit_1.Unit.METER);
            block1.P.x = 0;
            block1.P.y = 0;
            block1.P.uom = Unit_1.Unit.KILOGRAM_METER_PER_SECOND;
            var block2 = new Block2_1.Block2(Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER), Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER));
            block2.M = Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.KILOGRAM);
            block1.X = Geometric2_1.Geometric2.vector(1, 0, Unit_1.Unit.METER);
            block2.P.x = 0;
            block2.P.y = 0;
            block2.P.uom = Unit_1.Unit.KILOGRAM_METER_PER_SECOND;
            var spring = new Spring_1.Spring(block1, block2);
            spring.restLength = Geometric2_1.Geometric2.scalar(1, Unit_1.Unit.METER);
            expect(block1.X.x).toBe(1);
            expect(block1.X.y).toBe(0);
            engine.contents.addBody(block1);
            engine.contents.addBody(block2);
            engine.contents.addForceLaw(spring);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block1.X.x).toBe(1);
            expect(block1.X.y).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block1.X.x).toBe(1);
            expect(block1.X.y).toBe(0);
            // engine.strategy.advance(1, Unit.SECOND);
            // expect(block1.X.x).toBe(4.5);
            // expect(block1.X.y).toBe(0);
            // engine.strategy.advance(1, Unit.SECOND);
            // expect(block1.X.x).toBe(8);
            // expect(block1.X.y).toBe(0);
            // engine.strategy.advance(1, Unit.SECOND);
            // expect(block1.X.x).toBe(12.5);
            // expect(block1.X.y).toBe(0);
        });
        it("Euclidean3D", function () {
            var metric = new Euclidean3_1.Euclidean3();
            var dynamics = new Dynamics3_1.Dynamics3();
            var engine = new Engine_1.Engine(metric, dynamics);
            var block = new Block3_1.Block3(Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER), Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.METER));
            block.M = Geometric3_1.Geometric3.scalar(1, Unit_1.Unit.KILOGRAM);
            block.P.x = 0;
            block.P.y = 0;
            block.P.uom = Unit_1.Unit.KILOGRAM_METER_PER_SECOND;
            var F = new ConstantForceLaw_1.ConstantForceLaw(block, Geometric3_1.Geometric3.vector(1, 0, 0, Unit_1.Unit.NEWTON));
            engine.contents.addBody(block);
            engine.contents.addForceLaw(F);
            expect(block.X.x).toBe(0);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
            engine.strategy.advance(1, Unit_1.Unit.SECOND);
            expect(block.X.x).toBe(0.5);
            expect(block.X.y).toBe(0);
            expect(block.X.z).toBe(0);
        });
    });
});
