import AbstractSubject from '../util/AbstractSubject';
import contains from '../util/contains';
import DoubleRect from '../view/DoubleRect';
import GenericEvent from '../util/GenericEvent';
import GraphLine from './GraphLine';
import removeAt from '../util/removeAt';
import isDefined from '../checks/isDefined';
import repeat from '../util/repeat';
import SimView from '../view/SimView';
import SubjectEvent from '../util/SubjectEvent';
import veryDifferent from '../util/veryDifferent';

/**
 * 
 */
export default class AutoScale extends AbstractSubject {
    /**
     * Event broadcasted when axis is changed.
     */
    public static readonly AXIS = 'AXIS';
    /**
     * Event broadcasted when time window is changed.
     */
    public static readonly TIME_WINDOW = 'TIME_WINDOW';
    /**
     * Name of event broadcast when the active state changes, value is whether active.
     */
    public static readonly ACTIVE = 'ACTIVE';

    /**
     * Name of event broadcast when a new enclosing simulation rectangle has been calculated.
     */
    public static readonly AUTO_SCALE = 'AUTO_SCALE';

    /**
     * Specifies both axes option for {@link #setAxis}.
     */
    public static readonly BOTH_AXES = 'BOTH_AXES';

    /**
     * Name of event broadcast when the enabled state changes, value is whether enabled.
     */
    public static readonly ENABLED = 'ENABLED';

    /**
     * Specifies horizontal axis option for {@link #setAxis}.
     */
    public static readonly HORIZONTAL = 'HORIZONTAL';

    /**
     * Specifies vertical axis option for {@link #setAxis}.
     */
    public static readonly VERTICAL = 'VERTICAL';

    /**
     * The GraphLines to auto-scale.
     */
    private graphLines_: GraphLine[] = [];
    /**
     * 
     */
    private simView_: SimView;
    private enabled_ = true;
    private isActive_ = true;
    /**
     * Indicates that the SIM_RECT_CHANGED event was generated by this AutoScale.
     */
    private ownEvent_ = false;
    /**
     * `false` indicates that the range has never been set based on graph data
     */
    private rangeSetX_ = false;
    /**
     * `false` indicates that the range has never been set based on graph data
     */
    private rangeSetY_ = false;
    /**
     * the maximum horizontal value of the range, used for calculating the scale
     */
    private rangeXHi_ = 0;
    /**
     * the minimum horizontal value of the range, used for calculating the scale
     */
    private rangeXLo_ = 0;
    /**
     * the maximum vertical value of the range, used for calculating the scale
     */
    private rangeYHi_ = 0;
    /**
     * the minimum vertical value of the range, used for calculating the scale
     */
    private rangeYLo_ = 0;
    /**
     * Length of time to include in the range rectangle for a 'time graph'.
     */
    private timeWindow_ = 10;
    /**
     * How much extra margin to allocate when expanding the graph range: a fraction
     * typically between 0.0 and 1.0, adds this fraction times the current horizontal or
     * vertical range.
     * This does not guarantee a margin of this amount, it merely reduces the
     * frequency of range expansion.  You could for example expand the range, and then
     * have succeeding points come very close to the new range so that the graph goes
     * very close to the edge but stays within the range.
     */
    public extraMargin = 0.01;
    /**
     * Minimum size that range rectangle can be, for width and height.
     */
    private minSize = 1E-14;
    private axis_ = AutoScale.BOTH_AXES;
    /**
     * Index of last point seen within GraphPoints list of each GraphLine
     */
    private lastIndex_: number[];
    /**
     * 
     */
    constructor(name: string, graphLine: GraphLine, simView: SimView) {
        super(name);
        if (isDefined(graphLine) && !GraphLine.isDuckType(graphLine)) {
            throw new Error('not a GraphLine ' + graphLine);
        }
        if (GraphLine.isDuckType(graphLine)) {
            this.graphLines_.push(graphLine);
            graphLine.addObserver(this);
        }
        this.simView_ = simView;
        simView.addMemo(this);
        simView.addObserver(this);
        this.lastIndex_ = repeat(-1, this.graphLines_.length);
        this.setComputed(this.isActive_);
    }

    /**
     * Add a GraphLine which will be observed to calculate the range rectangle of points
     * on the line.
     * @param graphLine the GraphLine to add
     */
    addGraphLine(graphLine: GraphLine): void {
        if (GraphLine.isDuckType(graphLine)) {
            if (!contains(this.graphLines_, graphLine)) {
                this.graphLines_.push(graphLine);
                this.lastIndex_.push(-1);
            }
        } else {
            throw new Error('not a GraphLine ' + graphLine);
        }
    }

    /**
     * Clears the range rectangle, continues calculating from latest entry in HistoryList.
     */
    clearRange(): void {
        this.rangeXLo_ = 0;
        this.rangeXHi_ = 0;
        this.rangeSetX_ = false;
        this.rangeYLo_ = 0;
        this.rangeYHi_ = 0;
        this.rangeSetY_ = false;
    }

    /**
     * Returns whether is AutoScale is active.  See {@link #setActive}.
     * @return whether is AutoScale is active
     */
    getActive(): boolean {
        return this.isActive_;
    }

    /**
     * Returns which axis should be auto scaled: one of {@link #VERTICAL},
     * {@link #HORIZONTAL}, or {@link #BOTH_AXES}.
     * @return which axis should be auto scaled
     */
    getAxis(): string {
        return this.axis_;
    }

    /**
     * Returns whether is AutoScale is enabled.  See {@link #setEnabled}.
     * @return whether is AutoScale is enabled
     */
    getEnabled(): boolean {
        return this.enabled_;
    }

    /**
     * Returns the range rectangle that encloses points on the GraphLines, including any
     * extra margin. Note that this rectangle might not correspond to the SimView's simulation
     * rectangle, see {@link #setAxis}.
     * @return the range rectangle that encloses points on the GraphLines
     */
    getRangeRect(): DoubleRect {
        return new DoubleRect(this.rangeXLo_, this.rangeYLo_, this.rangeXHi_, this.rangeYHi_);
    }

    /**
     * Returns length of time to include in the range rectangle for a *time graph*.
     * @return length of time to include in the range rectangle
     */
    getTimeWindow(): number {
        return this.timeWindow_;
    }

    memorize(): void {
        for (var i = 0, n = this.graphLines_.length; i < n; i++) {
            var graphPts = this.graphLines_[i].getGraphPoints();
            // Detect when graphLine has been reset.
            if (this.lastIndex_[i] > graphPts.getEndIndex()) {
                this.reset();
            }
        }
        for (i = 0, n = this.graphLines_.length; i < n; i++) {
            graphPts = this.graphLines_[i].getGraphPoints();
            var iter = graphPts.getIterator(this.lastIndex_[i]);
            while (iter.hasNext()) {
                var gp = iter.nextValue();
                this.updateRange_(this.graphLines_[i], gp.x, gp.y);
                this.lastIndex_[i] = iter.getIndex();
            }
        }
        this.rangeCheck_();
    }

    observe(event: SubjectEvent): void {
        if (event.getSubject() === this.simView_) {
            if (event.nameEquals(SimView.SIM_RECT_CHANGED)) {
                if (!this.ownEvent_) {
                    // Become inactive when the SimView's simRect is changed by an entity other
                    // than this AutoScale.
                    this.setActive(false);
                }
            }
        } else if (contains(this.graphLines_, event.getSubject())) {
            if (event.nameEquals(GraphLine.PARAM_NAME_X_VARIABLE) || event.nameEquals(GraphLine.PARAM_NAME_Y_VARIABLE)) {
                // the GraphLine's X or Y variable has changed
                this.reset();
            }
            else if (event.nameEquals(GraphLine.RESET)) {
                // This has the effect of turning AutoScale back on
                // after clicking the 'clear graph' button.
                this.setActive(true);
            }
        }
    }

    /**
     * When the range rectangle changes, this will broadcast a GenericEvent named
     * `AutoScale.AUTO_SCALE`.
     */
    private rangeCheck_() {
        const e = this.minSize;
        // set range rectangle to minimum size, when range is very tiny
        // (but choose an increment that is big enough to make hi & lo different numbers)
        if (this.rangeXHi_ - this.rangeXLo_ < e) {
            const avg = (this.rangeXHi_ + this.rangeXLo_) / 2;
            const incr = Math.max(avg * e, e);
            this.rangeXHi_ = avg + incr;
            this.rangeXLo_ = avg - incr;
        }
        if (this.rangeYHi_ - this.rangeYLo_ < e) {
            const avg = (this.rangeYHi_ + this.rangeYLo_) / 2;
            const incr = Math.max(avg * e, e);
            this.rangeYHi_ = avg + incr;
            this.rangeYLo_ = avg - incr;
        }
        let nr = this.getRangeRect();
        const sr = this.simView_.getSimRect();
        if (this.axis_ === AutoScale.VERTICAL) {
            // set vertical range, but retain existing horiz range
            nr = new DoubleRect(sr.getLeft(), nr.getBottom(), sr.getRight(), nr.getTop());
        }
        else if (this.axis_ === AutoScale.HORIZONTAL) {
            // set horizontal range, but retain existing vertical range
            nr = new DoubleRect(nr.getLeft(), sr.getBottom(), nr.getRight(), sr.getTop());
        }
        if (this.isActive_ && !nr.nearEqual(sr)) {
            this.ownEvent_ = true;
            this.simView_.setSimRect(nr);
            this.ownEvent_ = false;
            this.broadcast(new GenericEvent(this, AutoScale.AUTO_SCALE, nr));
        }
    }

    /**
     * Remove a GraphLine, it will no longer be observed for calculating the range
     * rectangle of points on the line.
     * @param graphLine the GraphLine to remove
     */
    removeGraphLine(graphLine: GraphLine): void {
        if (GraphLine.isDuckType(graphLine)) {
            var idx = this.graphLines_.indexOf(graphLine);
            removeAt(this.graphLines_, idx);
            removeAt(this.lastIndex_, idx);
            this.reset();
        } else {
            throw new Error('not a GraphLine ' + graphLine);
        }
    }

    /**
     * Clears the range rectangle, and starts calculating from first entry in HistoryList.
     * Note that you will need to call {@link #memorize} to have the range recalculated.
     */
    reset() {
        this.clearRange();
        for (var i = 0, n = this.lastIndex_.length; i < n; i++) {
            this.lastIndex_[i] = -1;
        }
    }

    /**
     * Sets whether this AutoScale is active.  When not active, the range rectangle
     * is not updated and the SimView's simulation rectangle is not modified. When changed
     * to be active, this will also call {@link #reset}.
     * 
     * The AutoScale must be enabled in order to become active, see {@link #setEnabled}.
     * If not enabled, then this method can only make the AutoScale inactive.
     * @param value whether this AutoScale should be active
     */
    setActive(value: boolean): void {
        if (this.isActive_ !== value) {
            if (value) {
                if (this.enabled_) {
                    this.reset();
                    this.simView_.addMemo(this);
                    this.setComputed(true);
                    this.isActive_ = true;
                    this.broadcast(new GenericEvent(this, AutoScale.ACTIVE, this.isActive_));
                }
            }
            else {
                this.simView_.removeMemo(this);
                this.setComputed(false);
                this.isActive_ = false;
                this.broadcast(new GenericEvent(this, AutoScale.ACTIVE, this.isActive_));
            }
        }
    }

    /**
     * Set which axis to auto scale: one of {@link #VERTICAL}, {@link #HORIZONTAL}, or
     * {@link #BOTH_AXES}.
     * @param value which axis should be auto scaled
     */
    setAxis(value: string) {
        if (value === AutoScale.VERTICAL || value === AutoScale.HORIZONTAL || value === AutoScale.BOTH_AXES) {
            this.axis_ = value;
            this.broadcastParameter(AutoScale.AXIS);
        } else {
            throw new Error('unknown ' + value);
        }
    }

    /**
     * Marks the SimView's Parameters as to whether they are automatically computed
     * depending on whether this AutoScale is active.
     * @param value whether this AutoScale is computing the Parameter values
     */
    private setComputed(value: boolean): void {
        const names = [SimView.PARAM_NAME_WIDTH, SimView.PARAM_NAME_HEIGHT, SimView.PARAM_NAME_CENTER_X, SimView.PARAM_NAME_CENTER_Y];
        names.forEach((name) => {
            const p = this.simView_.getParameter(name);
            p.setComputed(value);
        });
    }

    /**
     * Sets whether this AutoScale is enabled. The AutoScale must be enabled in order
     * to be active.  See {@link #setActive}.
     * @param value whether this AutoScale should be enabled
     */
    setEnabled(value: boolean): void {
        if (this.enabled_ !== value) {
            this.enabled_ = value;
            this.setActive(value);
            this.broadcast(new GenericEvent(this, AutoScale.ENABLED, this.enabled_));
        }
    }

    /**
     * Sets length of time to include in the range rectangle for a *time graph*,
     * and sets the AutoScale to be active. See {@link #setActive}.
     * @param value length of time to include in the range rectangle
     */
    setTimeWindow(value: number): void {
        if (veryDifferent(value, this.timeWindow_)) {
            this.timeWindow_ = value;
            this.reset();
            // this fixes following bug: click pan-zoom control which makes AutoScale inactive;
            // then change the time window, but nothing happens.
            this.setActive(true);
            this.broadcastParameter(AutoScale.TIME_WINDOW);
        }
    }

    /**
     * Updates the graph range to include the given point. For time variable, limit the
     * range to the timeWindow. For non-time variable, expand the range an extra amount when
     * the range is exceeded; this helps avoid too many visually distracting updates.
     * @param line
     * @param nowX
     * @param nowY
     */
    private updateRange_(line: GraphLine, nowX: number, nowY: number): void {
        // To avoid infinity in the range, store a very large number instead.
        // Largest double precision floating point number is approx 1.8 * 10^308
        if (!isFinite(nowX)) {
            if (nowX === Number.POSITIVE_INFINITY) {
                nowX = 1e308;
            } else if (nowX === Number.NEGATIVE_INFINITY) {
                nowX = -1e308;
            }
        }
        if (!isFinite(nowY)) {
            if (nowY === Number.POSITIVE_INFINITY) {
                nowY = 1e308;
            } else if (nowY === Number.NEGATIVE_INFINITY) {
                nowY = -1e308;
            }
        }
        var timeIdx = line.getVarsList().timeIndex();
        var xIsTimeVar = line.getXVariable() === timeIdx;
        var yIsTimeVar = line.getYVariable() === timeIdx;
        if (!this.rangeSetX_) {
            this.rangeXLo_ = nowX;
            this.rangeXHi_ = nowX + (xIsTimeVar ? this.timeWindow_ : 0);
            this.rangeSetX_ = true;
        } else {
            if (nowX < this.rangeXLo_) {
                if (xIsTimeVar) {
                    this.rangeXLo_ = nowX;
                    this.rangeXHi_ = nowX + this.timeWindow_;
                } else {
                    this.rangeXLo_ = nowX - this.extraMargin * (this.rangeXHi_ - this.rangeXLo_);
                }
            }
            if (xIsTimeVar) {
                // In 'time graph', have extra space on right side so we can see
                // the leading edge hotspots.
                if (nowX > this.rangeXHi_ - this.extraMargin * this.timeWindow_) {
                    this.rangeXHi_ = nowX + this.extraMargin * this.timeWindow_;
                    this.rangeXLo_ = this.rangeXHi_ - this.timeWindow_;
                }
            } else {
                if (nowX > this.rangeXHi_) {
                    this.rangeXHi_ = nowX + this.extraMargin * (this.rangeXHi_ - this.rangeXLo_);
                }
            }
        }
        if (!this.rangeSetY_) {
            this.rangeYLo_ = nowY;
            this.rangeYHi_ = nowY + (yIsTimeVar ? this.timeWindow_ : 0);
            this.rangeSetY_ = true;
        } else {
            if (nowY < this.rangeYLo_) {
                if (yIsTimeVar) {
                    this.rangeYLo_ = nowY;
                    this.rangeYHi_ = nowY + this.timeWindow_;
                } else {
                    this.rangeYLo_ = nowY - this.extraMargin * (this.rangeYHi_ - this.rangeYLo_);
                }
            }
            if (yIsTimeVar) {
                // In 'time graph', have extra space on top so we can see
                // the leading edge hotspots.
                if (nowY > this.rangeYHi_ - this.extraMargin * this.timeWindow_) {
                    this.rangeYHi_ = nowY + this.extraMargin * this.timeWindow_;
                    this.rangeYLo_ = this.rangeYHi_ - this.timeWindow_;
                }
            } else {
                if (nowY > this.rangeYHi_) {
                    this.rangeYHi_ = nowY + this.extraMargin * (this.rangeYHi_ - this.rangeYLo_);
                }
            }
        }
    }
}
